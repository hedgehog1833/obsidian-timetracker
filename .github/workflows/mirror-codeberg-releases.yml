name: Mirror tags & releases from Codeberg

permissions:
  contents: write

on:
  workflow_dispatch:
  repository_dispatch:

jobs:
  mirror:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (full history)
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # 6.0.1
        with:
          fetch-depth: 0

      - name: Add Codeberg remote and fetch tags
        env:
          CODEBERG_URL: https://codeberg.org/hedgehog1833/obsidian-timetracker.git
        run: |
          git remote add codeberg "$CODEBERG_URL" || true
          git fetch codeberg --tags --prune

      - name: Push tags to GitHub
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git push https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository }} --tags

      - name: Setup Node
        uses: actions/setup-node@6044e13b5dc448c55e2357c09f80417699197238 # 6.2.0
        with:
          node-version: 24
          cache: 'npm'

      - name: Create GitHub releases for tags and upload assets
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # 8.0.0
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const execSync = require('child_process').execSync;
            const fs = require('fs');
            const filesForRelease = ['main.js', 'styles.css', 'manifest.json'];

            const lastTag = execSync('git tag --list --sort=-creatordate | head -n 1', { encoding: 'utf8' }).trim();

            if (!lastTag) {
              console.log('no tags found');
              return;
            } else {
              console.log(`latest tag is ${lastTag}`);
              return;
            }

            let release;
            try {
              const resp = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                lastTag
              });
              console.log(`found existing release for ${lastTag} (id: ${resp.data.id})`);
              return;
            } catch (err) {
              if (err.status === 404) {
                console.log(`creating draft release for ${lastTag}`);
                const createResp = await github.rest.repos.createRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag_name: lastTag,
                  name: lastTag,
                  body: `Mirror release for ${lastTag} from Codeberg`,
                  draft: true,
                  prerelease: false
                });
                release = createResp.data;
              } else {
                throw err;
              }
            }

            try {
              console.log(`fetching and checking out ${lastTag}`);
              try {
                execSync(`git fetch codeberg refs/tags/${lastTag}:refs/tags/${lastTag}`, { stdio: 'inherit' });
              } catch (fetchErr) {
                execSync('git fetch codeberg --tags', { stdio: 'inherit' });
              }
            
              execSync(`git checkout -f refs/tags/${lastTag}`, { stdio: 'inherit' });
              execSync('git clean -fdx', { stdio: 'inherit' });
                                      
              if (fs.existsSync('package.json')) {
                console.log('installing dependencies');
                execSync('npm ci', { stdio: 'inherit' });
                console.log('running build');
                execSync('npm run build', { stdio: 'inherit' });
              } else {
                console.log('no package.json, skipping build');
              }
            } catch (buildErr) {
              console.log(`build failed for ${lastTag}: ${buildErr.message}`);
              return;
            }

            const assetsResp = await github.rest.repos.listReleaseAssets({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: release.id,
              per_page: 100
            });
            const existingAssets = assetsResp.data.map(a => a.name);

            for (const f of filesForRelease) {
              if (existingAssets.includes(f)) {
                console.log(`asset ${f} already present for ${lastTag}`);
                continue;
              }

              try {
                if (!fs.existsSync(f)) {
                  console.log(`${f} not present in workspace for ${lastTag}, skipping`);
                  continue;
                }

                const blob = fs.readFileSync(f);
                console.log(`uploading ${f} for ${lastTag} (size: ${blob.length})`);

                await github.rest.repos.uploadReleaseAsset({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: release.id,
                  name: f,
                  data: blob,
                  headers: {
                    'content-type': 'application/octet-stream',
                    'content-length': blob.length
                  }
                });
              } catch (e) {
                console.log(`could not read ${f} at ${lastTag}: ${e.message}`);
              }
            }

            try {
              await github.rest.repos.updateRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.id,
                draft: false
              });
              console.log(`published release for ${lastTag} (id: ${release.id})`);
            } catch (e) {
              console.log(`failed to publish release for ${lastTag}: ${e.message}`);
              // await github.rest.repos.deleteRelease({ owner: context.repo.owner, repo: context.repo.repo, release_id: release.id });
            }
