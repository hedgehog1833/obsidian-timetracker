name: Mirror tags & releases from Codeberg

permissions:
  contents: write

on:
  workflow_dispatch:
  repository_dispatch:

jobs:
  mirror:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (full history)
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # 6.0.1
        with:
          fetch-depth: 0

      - name: Add Codeberg remote and fetch tags
        env:
          CODEBERG_URL: https://codeberg.org/hedgehog1833/obsidian-timetracker.git
        run: |
          git remote add codeberg "$CODEBERG_URL" || true
          git fetch codeberg --tags --prune

      - name: Push tags to GitHub
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git push https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository }} --tags

      - name: Setup Node
        uses: actions/setup-node@6044e13b5dc448c55e2357c09f80417699197238 # 6.2.0
        with:
          node-version: 24
          cache: 'npm'

      - name: Create GitHub releases for tags and upload assets
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # 8.0.0
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const execSync = require('child_process').execSync;
            const fs = require('fs');
            const files = ['main.js', 'styles.css', 'manifest.json'];

            const tagsOutput = execSync('git tag --list', { encoding: 'utf8' }).trim();
            if (!tagsOutput) {
              console.log('no tags found');
              return;
            }

            const tags = tagsOutput.split('\n').filter(Boolean);

            for (const tag of tags) {
              let release;
              try {
                const resp = await github.rest.repos.getReleaseByTag({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag
                });
                console.log(`found existing release for ${tag} (id: ${resp.data.id})`);
                continue;
              } catch (err) {
                if (err.status === 404) {
                  console.log(`creating release for ${tag}`);
                  const createResp = await github.rest.repos.createRelease({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    tag_name: tag,
                    name: tag,
                    body: `Mirror release for ${tag} from Codeberg`,
                    draft: false,
                    prerelease: false
                  });
                  release = createResp.data;
                } else {
                  throw err;
                }
              }

              try {
                console.log(`fetching and checking out ${tag}`);
                try {
                  execSync(`git fetch codeberg refs/tags/${tag}:refs/tags/${tag}`, { stdio: 'inherit' });
                } catch (fetchErr) {
                  execSync('git fetch codeberg --tags', { stdio: 'inherit' });
                }
              
                // checkout the tag into detached HEAD and clean workspace
                execSync(`git checkout -f refs/tags/${tag}`, { stdio: 'inherit' });
                execSync('git clean -fdx', { stdio: 'inherit' });
                                        
                if (fs.existsSync('package.json')) {
                  console.log('installing dependencies');
                  execSync('npm ci', { stdio: 'inherit' });
                  console.log('running build');
                  execSync('npm run build', { stdio: 'inherit' });
                } else {
                  console.log('no package.json, skipping build');
                }
              } catch (buildErr) {
                console.log(`build failed for ${tag}: ${buildErr.message}`);
                continue;
              }

              const assetsResp = await github.rest.repos.listReleaseAssets({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.id,
                per_page: 100
              });
              const existingAssets = assetsResp.data.map(a => a.name);

              for (const f of files) {
                if (existingAssets.includes(f)) {
                  console.log(`asset ${f} already present for ${tag}`);
                  continue;
                }

                try {
                  if (!fs.existsSync(f)) {
                    console.log(`${f} not present in workspace for ${tag}, skipping`);
                    continue;
                  }

                  const blob = fs.readFileSync(f);
                  console.log(`uploading ${f} for ${tag} (size: ${blob.length})`);

                  await github.rest.repos.uploadReleaseAsset({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    release_id: release.id,
                    name: f,
                    data: blob,
                    headers: {
                      'content-type': 'application/octet-stream',
                      'content-length': blob.length
                    }
                  });
                } catch (e) {
                  console.log(`could not read ${f} at ${tag}: ${e.message}`);
                }
              }
            }
